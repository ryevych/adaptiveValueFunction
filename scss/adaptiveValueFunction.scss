@function rem($px) {
   $result: $px / 16 + rem;
   @return $result;
}
@function em($px, $current: 16) {
   $result: $px / $current + em;
   @return $result;
}

//  Вспомагательная функия для миксина adaptiveValueModified
@function defineLineParameters($breakPoints, $i) {
   // Определяет параметры линии, заданной парой точек {x1, y1} и {x2, y2}
   // Точки берутся из списка $breakPoints, который имеет вид (x1, y1, x2, y2, ..., xN, yN)
   // Индекс $i задает выбор начальной точки  - $x1
   // Результат - список параметров (наклон, точка пересечения оси Y, формула прямой)

   $x1: nth($breakPoints, 2 * $i - 1);
   $x2: nth($breakPoints, 2 * $i + 1);
   $y1: nth($breakPoints, 2 * $i);
   $y2: nth($breakPoints, 2 * ($i + 1));

   $k: math.div($y2 - $y1, $x2 - $x1);
   $y0: -($x1 * $k) + $y1;

   $funcExpression: 0; // Оптимизация $funcExpression - избавление от члена вида 0 * vw
   @if ($k == 0) {
      $funcExpression: #{rem($y0)};
   } @else {
      @if ($y0 != 0) {
         $funcExpression: #{rem($y0)} + " + " + #{$k * 100}vw;
      } @else {
         $funcExpression: #{$k * 100}vw;
      }
   }
   $lineParameters: ();
   $lineParameters: append($lineParameters, $k);
   $lineParameters: append($lineParameters, $y0);
   $lineParameters: append($lineParameters, $funcExpression);
   @return $lineParameters;
}

@function adaptiveValueFunction($breakPoints...) {
   // Функция, которая воспроизводит произвольное заданное пользователем поведение (изменение) значения свойства.
   //
   // Поведение задается (табулируется) контрольными точками ($breakpoints).
   // Вывод в CSS -- в относительных единицах rem.
   //
   // Параметры:
   // $breakPoints -- список точек определяющих поведение свойства в формате
   // 	$значениеШириныВьюпорта1, $значениеСвойства1, ..., $значениеШириныВьюпортаN, $значениеСвойстваN.
   // 	Величины задаются в пикселях без указания единицы измерения.
   //  	$значениеШириныВьюпорта задаются строго в возрастающем порядке (положительные числа),
   // 	равных значений быть не должно:
   // 	$значениеШириныВьюпорта1 < $значениеШириныВьюпорта2 < ... < $значениеШириныВьюпортаN
   // 	Ограничений на $значениеСвойства нет -- любое положительное или отрицательное число, и ноль.
   //
   // Примеры:
   // 	adaptiveValueFunction(320, 20, 900, 30, 1600, 40) --
   // 	на 320px значение свойства равно 20px, на 900px - увеличивается до 30px, на 1600px - до 40px,
   // 	больше 1600px - продалжает расти (как и на участке от 900 до 1600px), меньше 320px -- продолжает падать
   // 	(как и на участке от 900 до 320px).
   //
   // 	adaptiveValueFunction( 320, 5, 991, 5, 992, 20, 1600, 40, 1700, 40) --
   // 	на 320px значение свойства равно 5px, до 991px - остается равным 5px, при 992px - скачкообразно возрастает
   // 	до 20px, на 1600px - увеличивается до 40px, больше 1600px - остается постоянным и равно 40px.
   //
   //		Если ширина вьюпорта меньше, чем $значениеШириныВьюпорта1, то поведение свойства аппроксимируется
   // 	линией с отрезка [$значениеШириныВьюпорта1, $значениеШириныВьюпорта2]; если больше, чем $значениеШириныВьюпортаN,
   // 	то линией с отрезка [$значениеШириныВьюпорта(N-1), $значениеШириныВьюпортаN].

   $breakPointsLength: length($breakPoints); // Длина аргумента $breakPoints (должна быть парным числом)
   $breakPointsPair: math.div($breakPointsLength, 2); // Количество точек, задающих поведение свойства
   $breakPointsEven: $breakPointsPair - math.round($breakPointsPair);
   @if ($breakPointsEven != 0) {
      // Проверка на парность длины аргумента $breakPoints
      @error "Список паарметров слишком краток -- возможно задано непарное количество точек.";
   }
   @if ($breakPointsLength < 4) {
      // Проверяем, чтоб имелось минимальное количество аргументов при вызове миксина. Если нет --
      // выводим ошибку
      @error "Список паарметров слишком краток, не хватает точек для определения поведения свойства!";
   } @else {
      @if ($breakPointsPair == 2) {
         // Если заданы только две пары точек - моментальный вывод в CSS
         $k: math.div(nth($breakPoints, 4) - nth($breakPoints, 2), nth($breakPoints, 3) - nth($breakPoints, 1));
         $y0: -(nth($breakPoints, 1) * $k) + nth($breakPoints, 2);
         $funcExpression: #{rem($y0)} + " + " + #{$k * 100}vw;

         $propertyValue: "";
         @if ($k == 0) {
            $propertyValue: rem($y0);
         } @else {
            @if ($y0 == 0) {
               $propertyValue: #{$k * 100}vw;
            } @else {
               $propertyValue: #{"calc(" + $funcExpression + ")"};
            }
         }
         @return $propertyValue;
      } @else if ($breakPointsPair == 3) {
         // Если заданы только три пары точек - оптимизируем результат, вывод в CSS
         $kList: ();
         $funcExpressionList: ();

         @for $i from 1 through 2 {
            $lineParameters: defineLineParameters($breakPoints, $i);
            $k: nth($lineParameters, 1);
            $y0List: nth($lineParameters, 2);
            $funcExpression: nth($lineParameters, 3);
            $kList: append($kList, $k);
            $funcExpressionList: append($funcExpressionList, $funcExpression);
         }

         $propertyValue: #{nth($funcExpressionList, 1)};
         @if (nth($kList, 2) > nth($kList, 1)) {
            $propertyValue: #{"max(" + $propertyValue + ", " + nth($funcExpressionList, 2) + ")"};
         } @else {
            $propertyValue: #{"min(" + $propertyValue + ", " + nth($funcExpressionList, 2) + ")"};
         }
         @return $propertyValue;
      } @else {
         // Количество пар даных больше трех

         // Вычисление константы
         $cumul: 0;
         @for $i from 2 through ($breakPointsPair - 1) {
            $cumul: $cumul + nth($breakPoints, 2 * $i);
         }

         // Основной блок
         $propertyValue: "";
         $propertyValueList: ();
         @for $i from 1 through ($breakPointsPair - 1) {
            $lineParameters: defineLineParameters($breakPoints, $i);
            $y1: nth($breakPoints, 2 * $i);
            $y2: nth($breakPoints, 2 * ($i + 1));
            $k: nth($lineParameters, 1);
            $y0: nth($lineParameters, 2);
            $funcExpression: nth($lineParameters, 3);

            @if ($k == 0) {
               // Значение свойства НЕ изменяется на участке $x1, $x2
               $cumul: $cumul - $y0;
            } @else {
               // Значение свойства изменяется на участке $x1, $x2
               @if ($i == 1) {
                  // Обработка первой записи в результат
                  @if ($k > 0) {
                     $propertyValue: #{"min(" + rem($y2) + ", " + $funcExpression + ")"};
                  } @else {
                     $propertyValue: #{"max(" + rem($y2) + ", " + $funcExpression + ")"};
                  }
                  $propertyValueList: append($propertyValueList, $propertyValue);
               } @else if ($i == ($breakPointsPair - 1)) {
                  // Обработка последней записи в результат
                  @if ($k > 0) {
                     $propertyValue: #{"max(" + rem($y1) + ", " + $funcExpression + ")"};
                  } @else {
                     $propertyValue: #{"min(" + rem($y1) + ", " + $funcExpression + ")"};
                  }
                  $propertyValueList: append($propertyValueList, $propertyValue);
               } @else {
                  // Последующие записи в результат
                  $propertyValue: #{"clamp(" +
                     rem(min($y1, $y2)) +
                     ", " +
                     $funcExpression +
                     ", " +
                     rem(max($y1, $y2)) +
                     ")"};
                  $propertyValueList: append($propertyValueList, $propertyValue);
               }
            }
         }
         // Формирование результата работы
         $propertyValue: nth($propertyValueList, 1);
         @if (length($propertyValueList) != 1) {
            @for $i from 2 through length($propertyValueList) {
               $propertyValue: #{$propertyValue + " + " + nth($propertyValueList, $i)};
            }
         }
         @if ($cumul > 0) {
            $propertyValue: #{"calc(" + $propertyValue + " - " + rem(max($cumul, -$cumul)) + ")"};
         } @else if($cumul < 0) {
            $propertyValue: #{"calc(" + $propertyValue + " + " + rem(max($cumul, -$cumul)) + ")"};
         }
         @return $propertyValue;
      }
   }
}
